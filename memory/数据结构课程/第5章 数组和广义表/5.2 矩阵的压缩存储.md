# 第5章 数组和广义表

## 5.2 矩阵的压缩存储（特殊矩阵与稀疏矩阵）

### 学习目标
- 理解什么时候需要压缩存储（空间/时间）以及常见类型的适用场景：对角矩阵、带状矩阵、稀疏矩阵等。
- 掌握三种常见压缩表示：
  - 对角存储（Diagonal storage）
  - 带状存储（Band storage）
  - 稀疏矩阵常用的压缩格式：三元组（COO）与压缩行存储（CSR/CRS）
- 能用 C89 风格写出一个稀疏矩阵从三元组到 CSR 的转换及按 CSR 打印非零元素的示例程序。
- 能根据具体问题选择合适存储格式并估算空间复杂度。

---

### 5.2.1 为什么要压缩存储
- 普通二维数组 A[m][n] 占用 m×n 个位置。若矩阵稀疏（大部分元素为 0），直接存储会浪费大量空间。
- 压缩存储保留非零元素及其位置信息，常用于数值计算、图的邻接矩阵表示与稀疏线性代数库。
- 选择存储策略取决于：
  - 非零元素密度（sparse vs dense）
  - 常用操作（随机访问 vs 行扫描 vs 列扫描 vs 矩阵向量乘法）

---

### 5.2.2 常见压缩格式（概念与空间代价）
1. 对角（Diagonal）存储
   - 适用：对角矩阵或主对角带宽小的矩阵（例如仅存 k 条对角线非零）。
   - 存储：只存每条对角线的元素（数组大小 ≈ n × number_of_diagonals）。
   - 访问：通过偏移计算定位到对应对角线位置，O(1)。

2. 带状（Band）存储
   - 适用：带状矩阵（非零仅集中在主对角线及其相邻小范围）。
   - 存储：按行把每一行的带内元素连续存放或按对角线存放，空间 ≈ n × band_width。

3. 稀疏矩阵常用格式
   - 三元组（COO, coordinate list）
     - 存储三列数组：row[], col[], val[]，长度为非零元素个数 nz。
     - 适合构造时插入非零；随机访问较慢（需要线性搜索或索引）。
     - 空间：O(nz)
   - 压缩行存储（CSR, Compressed Sparse Row，又称 CRS）
     - 存储：
       - val[nz]：非零值按行顺序存放
       - col[nz]：对应的列索引
       - row_ptr[m+1]：每行起始位置在 val/col 中的索引（row_ptr[i] 到 row_ptr[i+1]-1 为第 i 行的非零）
     - 优点：行遍历、矩阵向量乘法高效；随机取得某行的非零项是 O(#nonzeros_in_row)
     - 空间：O(nz + m + 1)

---

### 5.2.3 典型操作复杂度对比（以非零数 nz, 行数 m, 列数 n 表示）
- 存储空间：稠密 O(mn)，稀疏格式 O(nz)（加上 o(m) 的索引开销）
- 矩阵向量乘（y = A*x）：
  - 稠密：O(mn)
  - CSR：O(nz)
- 插入非零（构造阶段）：
  - COO：O(1)（append）
  - CSR：若在线构造需要先用 COO，再转换为 CSR；或采用动态结构按行收集再压缩。

---

### 5.2.4 C89 示例程序（三元组 -> CSR，并按 CSR 打印非零项）
要点：符合 C89 写法（变量在函数头声明），不使用 VLA。示例仅实现核心转换与打印，不做输入校验（按你要求不强化健壮性）。

```c
/* 5.2_CSR_example.c
   说明：
   - 输入格式（示例交互）：
     第一行：m n nz
     接下来 nz 行：r c val   （0 基下标）
   - 程序把三元组（COO）转换成 CSR 并打印 CSR 的三数组。
*/
#include <stdio.h>
#include <stdlib.h>

typedef struct {
    int *row;
    int *col;
    int *val;
    int nz;
} COO;

typedef struct {
    int *row_ptr; /* size m+1 */
    int *col;     /* size nz */
    int *val;     /* size nz */
    int m;
    int n;
    int nz;
} CSR;

/* 比较函数用于 qsort 对 COO 按行优先、列次序排序 */
static int coo_cmp(const void *a, const void *b)
{
    const int *pa = (const int *)a;
    const int *pb = (const int *)b;
    int ra = pa[0];
    int ca = pa[1];
    int rb = pb[0];
    int cb = pb[1];
    if (ra != rb) return (ra - rb);
    return (ca - cb);
}

/* 将三元组转换为按行排序的数组形式（用于 qsort） */
void coo_to_csr(int m, int n, COO *coo, CSR *csr)
{
    int i;
    int *tmp; /* 临时将三元组打包为二维 int 数组 [nz][3] 存放 r,c,val 以便 qsort */
    tmp = (int *)malloc(sizeof(int) * coo->nz * 3);
    for (i = 0; i < coo->nz; ++i) {
        tmp[i*3 + 0] = coo->row[i];
        tmp[i*3 + 1] = coo->col[i];
        tmp[i*3 + 2] = coo->val[i];
    }

    qsort(tmp, coo->nz, sizeof(int)*3, coo_cmp);

    csr->m = m;
    csr->n = n;
    csr->nz = coo->nz;
    csr->row_ptr = (int *)malloc(sizeof(int) * (m + 1));
    csr->col = (int *)malloc(sizeof(int) * coo->nz);
    csr->val = (int *)malloc(sizeof(int) * coo->nz);

    for (i = 0; i <= m; ++i) csr->row_ptr[i] = 0;

    for (i = 0; i < coo->nz; ++i) {
        int r = tmp[i*3 + 0];
        if (r >= 0 && r < m) csr->row_ptr[r + 1]++;
    }

    for (i = 1; i <= m; ++i) csr->row_ptr[i] += csr->row_ptr[i - 1];

    {
        int *pos = (int *)malloc(sizeof(int) * (m + 1));
        for (i = 0; i <= m; ++i) pos[i] = csr->row_ptr[i];
        for (i = 0; i < coo->nz; ++i) {
            int r = tmp[i*3 + 0];
            int c = tmp[i*3 + 1];
            int v = tmp[i*3 + 2];
            int p = pos[r++];
            csr->col[p] = c;
            csr->val[p] = v;
        }
        free(pos);
    }

    free(tmp);
}

void print_csr(const CSR *csr)
{
    int i;
    printf("row_ptr: ");
    for (i = 0; i <= csr->m; ++i) {
        printf("%d ", csr->row_ptr[i]);
    }
    printf("\ncol: ");
    for (i = 0; i < csr->nz; ++i) {
        printf("%d ", csr->col[i]);
    }
    printf("\nval: ");
    for (i = 0; i < csr->nz; ++i) {
        printf("%d ", csr->val[i]);
    }
    printf("\n");
}

int main(void)
{
    int m, n, nz;
    int i;
    if (scanf("%d %d %d", &m, &n, &nz) != 3) return 0;

    COO coo;
    coo.nz = nz;
    coo.row = (int *)malloc(sizeof(int) * nz);
    coo.col = (int *)malloc(sizeof(int) * nz);
    coo.val = (int *)malloc(sizeof(int) * nz);

    for (i = 0; i < nz; ++i) {
        scanf("%d %d %d", &coo.row[i], &coo.col[i], &coo.val[i]);
    }

    CSR csr;
    coo_to_csr(m, n, &coo, &csr);

    print_csr(&csr);

    free(coo.row);
    free(coo.col);
    free(coo.val);
    free(csr.row_ptr);
    free(csr.col);
    free(csr.val);
    return 0;
}
```